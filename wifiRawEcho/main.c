/*
Etienne Arlaud
Florenc Caminade
Thomas FLayols

Respond to ESP-NOW vendor specific action frame by sending another one
https://hackaday.io/project/161896
https://github.com/thomasfla/Linux-ESPNOW

Adapted from :
https://stackoverflow.com/questions/10824827/raw-sockets-communication-over-wifi-receiver-not-able-to-receive-packets

1/Find your wifi interface:
$ iwconfig

2/Setup your interface in monitor mode :
$ sudo ifconfig wlp5s0 down
$ sudo iwconfig wlp5s0 mode monitor
$ sudo ifconfig wlp5s0 up

3/Run this code as root
*/

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <linux/if_arp.h>
#include <arpa/inet.h>
#include <assert.h>
#include <linux/filter.h>

#define MY_MAC 0xf81a67b7eb0b

#define MAC_2_MSBytes(MAC)  ((uint64_t) MAC & (uint64_t) 0xffff00000000)>>(8*4)
#define MAC_4_LSBytes(MAC)  (uint64_t) MAC & (((uint64_t) 1<<(4*8))-1)

#define PACKET_LENGTH 400 //Approximate
#define MAX_PACKET_LEN 1000

#define FILTER_LENGTH 34
//generated with tcpdump -i wlp5s0 'type 0 subtype 0xd0 and wlan[24:4]=0x7f18fe34 and wlan[32]=221 and wlan[33:4]&0xffffff = 0x18fe34 and wlan[37]=0x4 and wlan dst f8:1a:67:b7:eb:0b' -dd
static struct sock_filter bpfcode[FILTER_LENGTH] = {
  { 0x30, 0, 0, 0x00000003 },
  { 0x64, 0, 0, 0x00000008 },
  { 0x7, 0, 0, 0x00000000 },
  { 0x30, 0, 0, 0x00000002 },
  { 0x4c, 0, 0, 0x00000000 },
  { 0x2, 0, 0, 0x00000000 },
  { 0x7, 0, 0, 0x00000000 },
  { 0x50, 0, 0, 0x00000000 },
  { 0x54, 0, 0, 0x000000fc },
  { 0x15, 0, 23, 0x000000d0 },
  { 0x40, 0, 0, 0x00000018 },
  { 0x15, 0, 21, 0x7f18fe34 },
  { 0x50, 0, 0, 0x00000020 },
  { 0x15, 0, 19, 0x000000dd },
  { 0x40, 0, 0, 0x00000021 },
  { 0x54, 0, 0, 0x00ffffff },
  { 0x15, 0, 16, 0x0018fe34 },
  { 0x50, 0, 0, 0x00000025 },
  { 0x15, 0, 14, 0x00000004 },
  { 0x50, 0, 0, 0x00000000 },
  { 0x45, 12, 0, 0x00000004 },
  { 0x45, 0, 6, 0x00000008 },
  { 0x50, 0, 0, 0x00000001 },
  { 0x45, 0, 4, 0x00000001 },
  { 0x40, 0, 0, 0x00000012 },
  { 0x15, 0, 7, 0x67b7eb0b },
  { 0x48, 0, 0, 0x00000010 },
  { 0x15, 4, 5, 0x0000f81a },
  { 0x40, 0, 0, 0x00000006 },
  { 0x15, 0, 3, MAC_4_LSBytes(MY_MAC) },
  { 0x48, 0, 0, 0x00000004 },
  { 0x15, 0, 1, MAC_2_MSBytes(MY_MAC) },
  { 0x6, 0, 0, 0x00040000 },
  { 0x6, 0, 0, 0x00000000 },
};

static uint8_t gu8a_dest_mac[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

void print_packet(uint8_t *data, int len)
{
    printf("----------------------------new packet-----------------------------------\n");
    int i;
    for (i = 0; i < len; i++)
    {
        if (i % 16 == 0)
            printf("\n");
        printf("0x%02x, ", data[i]);
    }
    printf("\n\n");
}

int create_raw_socket(char *dev, struct sock_fprog *bpf)
{
    struct sockaddr_ll s_dest_addr; //code from sender
    struct ifreq ifr;
    int fd, ifi, rb, attach_filter;;

    bzero(&s_dest_addr, sizeof(s_dest_addr));
    bzero(&ifr, sizeof(ifr));

    (void)memset(&s_dest_addr, 0, sizeof(s_dest_addr));

    fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    assert(fd != -1); //abort if error

    strncpy((char *)ifr.ifr_name, dev, IFNAMSIZ);
    ifi = ioctl(fd, SIOCGIFINDEX, &ifr);
    assert(ifi != -1); //abort if error

    s_dest_addr.sll_family = PF_PACKET;
    //we don't use a protocol above ethernet layer, just use anything here
    s_dest_addr.sll_protocol = htons(ETH_P_ALL);
    s_dest_addr.sll_ifindex = ifr.ifr_ifindex;
    s_dest_addr.sll_hatype = ARPHRD_ETHER;
    s_dest_addr.sll_pkttype = PACKET_OTHERHOST; //PACKET_OUTGOING
    s_dest_addr.sll_halen = ETH_ALEN;
    //MAC - begin
    s_dest_addr.sll_addr[0] = gu8a_dest_mac[0];
    s_dest_addr.sll_addr[1] = gu8a_dest_mac[1];
    s_dest_addr.sll_addr[2] = gu8a_dest_mac[2];
    s_dest_addr.sll_addr[3] = gu8a_dest_mac[3];
    s_dest_addr.sll_addr[4] = gu8a_dest_mac[4];
    s_dest_addr.sll_addr[5] = gu8a_dest_mac[5];
    //MAC - end
    s_dest_addr.sll_addr[6] = 0x00; //not used
    s_dest_addr.sll_addr[7] = 0x00; //not used

    rb = bind(fd, (struct sockaddr *)&s_dest_addr, sizeof(s_dest_addr));
    assert(rb != -1); //abort if error

    attach_filter = setsockopt(fd, SOL_SOCKET, SO_ATTACH_FILTER, bpf, sizeof(*bpf));
    assert(attach_filter != -1);

    return fd;
}

int32_t send_echo(int sock_fd, uint8_t code) {
      int32_t s32_res;

      uint8_t data[331] = {
          0x00, 0x00, 0x26, 0x00, 0x2f, 0x40, 0x00, 0xa0, 0x20, 0x08, 0x00, 0xa0, 0x20, 0x08, 0x00, 0x00,
          0xdf, 0x32, 0xfe, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0c, 0x6c, 0x09, 0xc0, 0x00, 0xd3, 0x00,
          0x00, 0x00, 0xd3, 0x00, 0xc7, 0x01, 0xd0, 0x00, 0x3a, 0x01, 0x84, 0xf3, 0xeb, 0x73, 0x55, 0x0d,
          0xf8, 0x1a, 0x67, 0xb7, 0xeb, 0x0b, 0x84, 0xf3, 0xeb, 0x73, 0x55, 0x0d, 0x70, 0x51, 0x7f, 0x18,
          0xfe, 0x34, 0xa2, 0x03, 0x92, 0xb0, 0xdd, 0xff, 0x18, 0xfe, 0x34, 0x04, 0x01, 0x29, code, code,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x1c, 0xd5, 0x35, 0xd3}; //FROM TLINK TO ESP

      s32_res = sendto(sock_fd,data,331,0,NULL,0);

      return s32_res;
}

int main(int argc, char **argv)
{
    assert(argc == 2);

    char *dev = argv[1];

    uint8_t buff[MAX_PACKET_LEN] = {0};
    int sock_fd = -1;
    int s32_res = -1;

    struct sock_fprog bpf = {FILTER_LENGTH, bpfcode};

    sock_fd = create_raw_socket(dev, &bpf); /* Creating the raw socket */

    if (-1 == sock_fd)
    {
        perror("Could not create the socket");
        goto LABEL_CLEAN_EXIT;
    }

    printf("Socket created\n");

    fflush(stdout);

    sleep(1);

    int receiveCount = 0;

    while (1)
    {
        int len = recvfrom(sock_fd, buff, MAX_PACKET_LEN, MSG_TRUNC, NULL, 0);

        if (len < 0)
        {
            perror("Socket receive failed or error");
            break;
        }
        else if(len > 77)
        {
            printf("Receive Count %d\n", receiveCount++);
            print_packet(buff, len);
            s32_res = send_echo(sock_fd, buff[77]);

            if (-1 == s32_res)
            {
                perror("Socket send failed");
                goto LABEL_CLEAN_EXIT;
            } else {
              printf("Echo sent\n");
            }
        }
    }

LABEL_CLEAN_EXIT:
    if (sock_fd > 0)
    {
        close(sock_fd);
    }

    printf("***** Raw Socket test- end\n");

    return EXIT_SUCCESS;
}
